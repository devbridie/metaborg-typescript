\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{listings}

\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatimbox}
\usepackage{url}
\usepackage{hyperref}

\newcommand{\ttt}[1]{\texttt{#1}}

\lstdefinelanguage{typescript} {
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with, string, number, boolean, void, yield, async, class, interface, const, let},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  morestring=[b]`,
  sensitive=true
}

\lstset{language=java, showstringspaces=false, basicstyle=\small,
  numbers=left, numberstyle=\tiny, numberfirstline=false, breaklines=true,
  stepnumber=1, tabsize=8, 
  commentstyle=\ttfamily, identifierstyle=\ttfamily,
  stringstyle=\itshape}

\title{Language Engineering Project - Statix Description}
\author{Michiel van Spaendonck (4310071), Nouri Khalass (4742397)}

\begin{document}

\maketitle

\section*{Introduction}
In this document we will describe our findings while working on Statix in the context of structural types.
We do this by analysing the workings of \texttt{Statix} in the context of \texttt{TypeScript}.
Our work can be considered somewhat of a continuation of a previous analysis of \texttt{TypeScript}~\cite{MetaTypeScript}.
The authors go into detail as to how \texttt{TypeScript} could be modelled in a constraint based type checker.

\section*{Structural Types}
In a stuctural type systems types are said to be equivalent when they are of the same structure.
This as opposed to types in a nominal type system where only the name of a type has to be equivalent.
In a nominal type system two objects are not of the same type even though they might have identical member values.
Compare Listing~\ref{lst:structural_typescript} with Listing~\ref{lst:structural_java}.
In Listing~\ref{lst:structural_typescript} both \ttt{a} and \ttt{b} are of the same type.
Simply put, it would be valid to assign \ttt{a} to \ttt{b} since both only have one member \ttt{z} of type \ttt{number}.
However, Listing~\ref{lst:structural_java} shows a nominal type system whereby this is not valid.

\noindent
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:structural_typescript}
    ]{structural_types.ts}
\end{minipage}
\hfill$\Longleftrightarrow$\hfill\hfill\hfill
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:structural_java}
    ]{structural_types.java}
\end{minipage}
\\\\
The examples in Listing~\ref{lst:structural_typescript} and Listing~\ref{lst:structural_java} are obviously very trivial and might make one wonder why a nominal type system should be used.
What is not apparent from these examples is the fact that structural type systems can introduce quite a bit of overhead when type checking since the checker has to recurse over all members in the type.
On the other hand, a structural type system offers lots of flexibility and is interesting when dealing with a ``loose'' type system.
It is for this reason that \ttt{TypeScript}, which we are going to analyse, uses a structural type system, since it lies on top of the dynamic type system of \ttt{JavaScript}.

Another downside to structural type systems is the fact that they are difficult to implement.
Van der Lippe et al.~\cite{MetaTypeScript} noted that implementing the \ttt{TypeScript} type system proved to be very difficult.
They used NaBL2~\cite{nabl2} to model the type system but found that it lacked features in order to do this correctly.
They proposed some extensions to \ttt{NaBL2} and mentioned the idea of using scope graphs to model structural types~\cite{MetaTypeScript}.

\section*{Statix}
Van Antwerpen et al. have designed a programming language that makes it possible to model structural type systems~\cite{Statix}.
They are also the creators of \ttt{NaBL2}~\cite{nabl2}.
Their proposed system to use \textit{scopes as types}.

TODO: EXPLAIN WHY A STRUCTURAL TYPE SYSTEM CAN BE MODELLED (EASY) IN STATIX

\section*{Structural Types in Practice}
While Listing~\ref{lst:structural_typescript} and Listing~\ref{lst:structural_java} show a very trivial example it is more valuable to now look at a more complex case.
Throughout this paper we will give examples using \ttt{TypeScript}.
The first example that we will look at is a more complex showcase of structural typing (Listing~\ref{lst:complex_i}).
\noindent
\begin{center}
    \begin{minipage}{.60\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:complex_i}
        ]{complex_i.ts}
    \end{minipage}
\end{center}
In Listing~\ref{lst:complex_i} we show that types are not bound to names.
We define two interfaces, \ttt{A} and \ttt{B}, with both a property named \ttt{z} of type \ttt{string}.
Variable \ttt{a} can be initialised by creating an object with a property \ttt{z}.
Following that, variable \ttt{b} can be initialised with \ttt{a} because even though they do not use the same type name the type that they represent is structurally equivalent.
Variable \ttt{c} is not of any predefined types but instead declares the structure of the type inline.
It is valid to assign \ttt{b} to \ttt{c} since they both have a value which has the same type structure.
\\\\
The type system in \ttt{TypeScript} has the notion of \textit{subtyping} whereby it is required that all properties of the \textit{supertype} are present in the \textit{subtype}.
As such, a subtype can be seen as a more general version of its supertype.
Listing~\ref{lst:records} shows this behaviour.
\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:records}
        ]{subtyping.ts}
    \end{minipage}
\end{center}
We define a function \ttt{doSomething} which has one parameter named \ttt{param}.
\ttt{param} itself must have a property \ttt{x} of type \ttt{string}, so we \textit{must} call \ttt{doSomething} with a value which has a property \ttt{x} of type \ttt{string}.
Next, we define a variable \ttt{z} which has two properties.
The first property is \ttt{x} of type \ttt{string} and the second is \ttt{y} of type \ttt{number}.
Finally, we can safely call \ttt{doSomething} with \ttt{z} even though \ttt{z} has a property \ttt{y} in which we are not interested.
We have satisfied the constraint of property \ttt{x} with type \ttt{string} and the resulting code is valid.

Note that \ttt{z} itself is initialised with an object that has a property \ttt{x} of value \ttt{""} (empty string) and property \ttt{y} of value \ttt{42}.
If \ttt{x} would also be given the value \ttt{42} then the assignment would be invalid since both properties \ttt{x} and \ttt{y} of the object would be of type \ttt{number} and \ttt{z} expects \ttt{x} to be of type \ttt{string}.

\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:nominal_i}
        ]{nominal_i.ts}
    \end{minipage}
\end{center}
To prove that \ttt{TypeScript} does not have a notion of nominal typing we present Listing~\ref{lst:nominal_i}.
We define two interfaces, \ttt{Foo} and \ttt{Bar} which both have the same properties \ttt{x} of type \ttt{string} and \ttt{y} of type \ttt{number}.
Next we declare a variable \ttt{v} of type \ttt{Bar} and initialise it with an object literal.
Following that we declare a variable \ttt{w} which is of type \ttt{Foo} and assign \ttt{v} to it.
Even though \ttt{w} is of type \ttt{Foo} we can still assign something of type \ttt{Bar} since it has the same properties.
This is similar to Listing~\ref{lst:complex_i}.

\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:nominal_ii}
        ]{nominal_ii.ts}
    \end{minipage}
\end{center}

Now, we extend Listing~\ref{lst:nominal_i} to Listing~\ref{lst:nominal_ii}.
We also declare a function \ttt{doSomething} which has one parameter \ttt{val} of type \ttt{Bar}.
Again, we declare a variable \ttt{v} which we initialize with an object.
However, this time we also add a property \ttt{z} of type \ttt{boolean} to the object literal.
One might expect this to be valid because, even though \ttt{Bar} does not have a property \ttt{z} of type \ttt{boolean}, you would expect the compiler to ignore this because all other properties of \ttt{Bar} are satisfied.
In Listing~\ref{lst:records} we saw that we could call \ttt{doSomething} with an object which had more properties than we were interested in.
Still, the compiler would ignore this and the code would be valid.
Yet the code in Listing~\ref{lst:nominal_ii} is not valid.
In \ttt{TypeScript} it is not allowed to initialise a variable with an object literal which has properties that are not defined on the type.
It is also not valid to assign \ttt{v} to \ttt{w} since \ttt{v} is missing property \ttt{z} of type \ttt{boolean}; this happens on line 17. 


\section*{Modelling Structural Types in Statix}
To explain how \ttt{TypeScript} can be modelled using Statix we are going to look at a few examples.
First, modelling a type system that does not necessary rely on structural typing is easy.
Listing~\ref{lst:statix_code_i} shows a simple program supporting expressions with \ttt{number}, \ttt{string} and \ttt{boolean} type.
Next to that, Listing~\ref{lst:statix_impl_i} shows what the corresponding constraint rules might look like.

\noindent
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:statix_code_i}
    ]{statix_code_i.ts}
\end{minipage}
\hfill$\Longleftrightarrow$\hfill\hfill\hfill
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:statix_impl_i}
    ]{statix_impl_i.stx}
\end{minipage}
First, in Listing~\ref{lst:statix_impl_i} we define a rule \ttt{typeOfExpr} which consists of two arguments and returns a result.
The first argument is the scope in which we evaluate the expression.
The second argument specifies the \ttt{Expression} which will be evaluated.
Finally, given a scope and an \ttt{Expression} we say that we return something that is a \ttt{Type}.

Now, line 4, 5 and 6 specify the \ttt{typeOfExpr} rule for different types of \ttt{Expression}s.
A programming language might have multiple ways to denote an expression.
In this case numeric, string and boolean literals are available.
We specify that each variant of an \ttt{Expression} resolves to is appropriate type.
For example, a \ttt{NumberLiteral} is of \ttt{Type} \ttt{Number}.
Notice that none of the specification use the scope \ttt{s}.
This makes sense for literals but when we must resolve the type of an \ttt{Identifier} \ttt{Expression} then we would probably need to use the scope to access the corresponding declaration.

\bibliographystyle{ieeetr}
\bibliography{bibliography}

\end{document}