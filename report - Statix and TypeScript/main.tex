\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{listings}

\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatimbox}
\usepackage{url}
\usepackage{hyperref}

\newcommand{\ttt}[1]{\texttt{#1}}

\lstdefinelanguage{typescript} {
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with, string, number, boolean, void, yield, async, class, interface, const, let},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  morestring=[b]`,
  sensitive=true
}

\lstdefinelanguage{statix} {
  keywords={scope, rules, constraint, sorts, relations, namespaces, constructors, occurrence, labels, resolve, filter, min, query, new, with, decl, filter, and, in, path, pathMatch, pathLT, list},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  morestring=[b]`,
  sensitive=true
}

\lstset{
  showstringspaces=false, 
  basicstyle=\small,
  numbers=left, 
  numberstyle=\tiny, 
  numberfirstline=false, 
  breaklines=true,
  stepnumber=1, 
  tabsize=4, 
  commentstyle=\ttfamily, 
  identifierstyle=\ttfamily,
  stringstyle=\itshape
}

\title{Language Engineering Project - Statix Description}
\author{Michiel van Spaendonck (4310071), Nouri Khalass (4742397)}

\begin{document}

\maketitle

\section*{Introduction}
In this document we will describe our findings while working on Statix in the context of structural types.
We do this by analysing the workings of \texttt{Statix} in the context of \texttt{TypeScript}.
Our work can be considered somewhat of a continuation of a previous analysis of \texttt{TypeScript}~\cite{MetaTypeScript}.
The authors go into detail as to how \texttt{TypeScript} could be modelled in a constraint based type checker.

\section*{Structural Types}
In a structural type systems types are said to be equivalent when they are of the same structure.
This as opposed to types in a nominal type system where only the name of a type has to be equivalent.
In a nominal type system two objects are not of the same type even though they might have identical member values.
Compare Listing~\ref{lst:structural_typescript} with Listing~\ref{lst:structural_java}.
In Listing~\ref{lst:structural_typescript} both \ttt{a} and \ttt{b} are of the same type.
Simply put, it would be valid to assign \ttt{a} to \ttt{b} since both only have one member \ttt{z} of type \ttt{number}.
However, Listing~\ref{lst:structural_java} shows a nominal type system whereby this is not valid.

\noindent
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:structural_typescript}
    ]{structural_types.ts}
\end{minipage}
\hfill$\Longleftrightarrow$\hfill\hfill\hfill
\begin{minipage}{.45\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:structural_java}
    ]{structural_types.java}
\end{minipage}
\\\\
The examples in Listing~\ref{lst:structural_typescript} and Listing~\ref{lst:structural_java} are obviously very trivial and might make one wonder why a nominal type system should be used.
What is not apparent from these examples is the fact that structural type systems can introduce quite a bit of overhead when type checking since the checker has to recurse over all members in the type.
On the other hand, a structural type system offers lots of flexibility and is interesting when dealing with a ``loose'' type system.
It is for this reason that \ttt{TypeScript}, which we are going to analyse, uses a structural type system, since it lies on top of the dynamic type system of \ttt{JavaScript}.

Another downside to structural type systems is the fact that they are difficult to implement.
Van der Lippe et al.~\cite{MetaTypeScript} noted that implementing the \ttt{TypeScript} type system proved to be very difficult.
They used NaBL2~\cite{nabl2} to model the type system but found that it lacked features in order to do this correctly.
They proposed some extensions to \ttt{NaBL2} and mentioned the idea of using scope graphs to model structural types~\cite{MetaTypeScript}.

\section*{Statix}
Van Antwerpen et al. have designed a programming language that makes it possible to model structural type systems~\cite{Statix}.
They are also the creators of \ttt{NaBL2}~\cite{nabl2}.
Their proposed system to use \textit{scopes as types}.

TODO: EXPLAIN WHY A STRUCTURAL TYPE SYSTEM CAN BE MODELLED (EASY) IN STATIX

\section*{Structural Types in Practice}
While Listing~\ref{lst:structural_typescript} and Listing~\ref{lst:structural_java} show a very trivial example it is more valuable to now look at a more complex case.
Throughout this paper we will give examples using \ttt{TypeScript}.
The first example that we will look at is a more complex showcase of structural typing (Listing~\ref{lst:complex_i}).
\noindent
\begin{center}
    \begin{minipage}{.60\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:complex_i}
        ]{complex_i.ts}
    \end{minipage}
\end{center}
In Listing~\ref{lst:complex_i} we show that types are not bound to names.
We define two interfaces, \ttt{A} and \ttt{B}, with both a property named \ttt{z} of type \ttt{string}.
Variable \ttt{a} can be initialised by creating an object with a property \ttt{z}.
Following that, variable \ttt{b} can be initialised with \ttt{a} because even though they do not use the same type name the type that they represent is structurally equivalent.
Variable \ttt{c} is not of any predefined types but instead declares the structure of the type inline.
It is valid to assign \ttt{b} to \ttt{c} since they both have a value which has the same type structure.
\\\\
The type system in \ttt{TypeScript} has the notion of \textit{subtyping} whereby it is required that all properties of the \textit{supertype} are present in the \textit{subtype}.
As such, a subtype can be seen as a more general version of its supertype.
Listing~\ref{lst:records} shows this behaviour.
\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:records}
        ]{subtyping.ts}
    \end{minipage}
\end{center}
We define a function \ttt{doSomething} which has one parameter named \ttt{param}.
\ttt{param} itself must have a property \ttt{x} of type \ttt{string}, so we \textit{must} call \ttt{doSomething} with a value which has a property \ttt{x} of type \ttt{string}.
Next, we define a variable \ttt{z} which has two properties.
The first property is \ttt{x} of type \ttt{string} and the second is \ttt{y} of type \ttt{number}.
Finally, we can safely call \ttt{doSomething} with \ttt{z} even though \ttt{z} has a property \ttt{y} in which we are not interested.
We have satisfied the constraint of property \ttt{x} with type \ttt{string} and the resulting code is valid.

Note that \ttt{z} itself is initialised with an object that has a property \ttt{x} of value \ttt{""} (empty string) and property \ttt{y} of value \ttt{42}.
If \ttt{x} would also be given the value \ttt{42} then the assignment would be invalid since both properties \ttt{x} and \ttt{y} of the object would be of type \ttt{number} and \ttt{z} expects \ttt{x} to be of type \ttt{string}.

\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:nominal_i}
        ]{nominal_i.ts}
    \end{minipage}
\end{center}
To prove that \ttt{TypeScript} does not have a notion of nominal typing we present Listing~\ref{lst:nominal_i}.
We define two interfaces, \ttt{Foo} and \ttt{Bar} which both have the same properties \ttt{x} of type \ttt{string} and \ttt{y} of type \ttt{number}.
Next we declare a variable \ttt{v} of type \ttt{Bar} and initialise it with an object literal.
Following that we declare a variable \ttt{w} which is of type \ttt{Foo} and assign \ttt{v} to it.
Even though \ttt{w} is of type \ttt{Foo} we can still assign something of type \ttt{Bar} since it has the same properties.
This is similar to Listing~\ref{lst:complex_i}.

\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = typescript, 
        caption = \label{lst:nominal_ii}
        ]{nominal_ii.ts}
    \end{minipage}
\end{center}
Now, we extend Listing~\ref{lst:nominal_i} to Listing~\ref{lst:nominal_ii}.
We also declare a function \ttt{doSomething} which has one parameter \ttt{val} of type \ttt{Bar}.
Again, we declare a variable \ttt{v} which we initialise with an object.
However, this time we also add a property \ttt{z} of type \ttt{boolean} to the object literal.
One might expect this to be valid because, even though \ttt{Bar} does not have a property \ttt{z} of type \ttt{boolean}, you would expect the compiler to ignore this because all other properties of \ttt{Bar} are satisfied.
In Listing~\ref{lst:records} we saw that we could call \ttt{doSomething} with an object which had more properties than we were interested in.
Still, the compiler would ignore this and the code would be valid.
Yet the code in Listing~\ref{lst:nominal_ii} is not valid.
In \ttt{TypeScript} it is not allowed to initialise a variable with an object literal which has properties that are not defined on the type.
It is also not valid to assign \ttt{v} to \ttt{w} since \ttt{v} is missing property \ttt{z} of type \ttt{boolean}; this happens on line 17. 

\section*{Modelling Structural Types in Statix}
To explain how \ttt{TypeScript} can be modelled using Statix we are going to look at a few examples.
First, modelling a type system that does not necessary rely on structural typing is easy.
Listing~\ref{lst:statix_code_i} shows a simple program supporting expressions with \ttt{number}, \ttt{string} and \ttt{boolean} type.
Next to that, Listing~\ref{lst:statix_impl_i} shows what the corresponding constraint rules might look like.

\noindent
\begin{minipage}{.29\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:statix_code_i}
    ]{statix_code_i.ts}
\end{minipage}
\hfill$\Longleftrightarrow$\hfill\hfill\hfill
\begin{minipage}{.61\textwidth}
\lstinputlisting[
    language = c++, 
    caption = \label{lst:statix_impl_i}
    ]{statix_impl_i.stx}
\end{minipage}
First, in Listing~\ref{lst:statix_impl_i} we define a rule \ttt{typeOfExpr} which consists of two arguments and returns a result.
The first argument is the scope in which we evaluate the expression.
The second argument specifies the \ttt{Expression} which will be evaluated.
Finally, given a scope and an \ttt{Expression} we say that we return something that is a \ttt{Type}.

Now, line 4, 5 and 6 specify the \ttt{typeOfExpr} rule for different types of \ttt{Expression}s.
A programming language might have multiple ways to denote an expression.
In this case numeric, string and boolean literals are available.
We specify that each variant of an \ttt{Expression} resolves to is appropriate type.
For example, a \ttt{NumberLiteral} is of \ttt{Type} \ttt{Number}.
Notice that none of the specification use the scope \ttt{s}.
This makes sense for literals but when we must resolve the type of an \ttt{Identifier} \ttt{Expression} then we would probably need to use the scope to access the corresponding declaration.
\\\\
The \ttt{Type}s that are used in Listing~\ref{lst:statix_impl_i} need to be declared.
We have a \ttt{Number}, \ttt{String} and \ttt{Boolean} type, and one might imagine having an \ttt{Object} type which relates to an object with properties.
In \ttt{Statix} it is required to declare ``constructors'' for each of these types.
Listing~\ref{lst:statix_type_decls} shows the constructors for each of the before mentioned types.

\begin{center}
    \begin{minipage}{.35\textwidth}
    \lstinputlisting[
        language = statix, 
        caption = \label{lst:statix_type_decls}
        ]{statix_type_decls.stx}
    \end{minipage}
\end{center}
We specify that a \ttt{Number} is a \ttt{Type} and that a \ttt{String} is a \ttt{Type} etc.
Notice that an \ttt{Object} has a scope and also resolves to \ttt{Type}, similar to \ttt{Number}.
The scope holds the properties that are present in the object.

As was shown in Listing~\ref{lst:nominal_i}, \ttt{TypeScript} relies purely on structural typing.
It is not the name of the type that is important but the structure of the type that decides whether two types are equal.

For this reason we need rules to check if types are equal.
These rules are simple for the basic types like \ttt{String} and \ttt{Number}.
However, checking whether two \ttt{Object} types are equal requires a structural check.
First we will give the \ttt{Statix} rules which check if the simple types are equal.
In Listing~\ref{lst:is_subtype_i} we declare a \textit{constraint} called \ttt{is\_subtype}.
This constraint will hold when a type \ttt{A} is a subtype of \ttt{B}.
A subtype must have all properties which are present in the supertype, but can also have additional properties not present in the supertype.
\ttt{Number}, \ttt{String} and \ttt{Boolean} are always the subtype to themselves because they are equal to themselves.

\begin{center}
    \begin{minipage}{.55\textwidth}
    \lstinputlisting[
        language = statix, 
        caption = \label{lst:is_subtype_i}
        ]{is_subtype_i.stx}
    \end{minipage}
\end{center}
Now, checking whether an \ttt{Object} type is a subtype of another \ttt{Object} type requires recursively going over all the properties in the supertype and checking whether they are present in the subtype.

\begin{center}
    \begin{minipage}{.75\textwidth}
    \lstinputlisting[
        language = statix, 
        caption = \label{lst:is_subtype_ii}
        ]{is_subtype_ii.stx}
    \end{minipage}
\end{center}
\noindent
In Listing~\ref{lst:is_subtype_ii} we introduce a new \ttt{is\_subtype} rule for \ttt{Object}s.
In order to validate that the properties of the supertype are present in the subtype we need to gather all available properties in the supertype.
We do this by performing a query.
Line 2 and 5 say that we are interested in all declarations in the scope of \ttt{p1}.
Because we are only interested in declarations that are of type \ttt{Property} we use \ttt{filter} on line 3 to filter out all other types of declarations.
Next we have to take into account shadowing caused by looking how the path must resolve.
\ttt{properties} will be an array of tuples and these tuples will be pairs of \ttt{path}s and \ttt{occurrence}s.
Finally, on line 6 we start the process of recursively going over the properties of \ttt{p2}.
\\
\noindent
We define \ttt{compare\_properties} to compare the structure of two \ttt{Objects}.
Given a scope \ttt{properties} we check if a property \ttt{d2} can be resolved.
If that is the case then we have a scope \ttt{p1} and an \ttt{occurrence} \ttt{d1}.
Next we receive the type of the occurrences \ttt{d1} and \ttt{d2} respectively in \ttt{T1} and \ttt{T2}.
Finally, to check whether these two types are equal we call \ttt{is\_subtype} again which checks if the new types are also equal.

\bibliographystyle{ieeetr}
\bibliography{bibliography}

\end{document}