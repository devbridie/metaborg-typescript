module typescript

signature
  sorts ID = string
  
  sorts Program
  constructors
    Program: list(Statement) -> Program

  sorts Statement
  constructors
    VarDecl  : ID * TypeExpr * Expression -> Statement
    TypeDecl : ID * TypeExpr -> Statement
    FuncDecl : ID * list((ID * TypeExpr)) * TypeExpr * list(Statement) -> Statement
    
    Assignment : ID * Expression -> Statement
    Return : Expression -> Statement
    Interface : ID * list((ID * TypeExpr)) -> Statement

  sorts Expression
  constructors
    Identifier     : list(ID) -> Expression
    FunctionCall   : ID * list(Expression) -> Expression
    NumberLiteral  : ID -> Expression
    StringLiteral  : ID -> Expression
    BooleanLiteral : Expression
    ObjectLiteral  : list((ID * Expression)) -> Expression

  sorts Type
  constructors
    Void : Type
  
    Number : scope -> Type
    String : scope -> Type
    Boolean : scope -> Type
    
    Object : scope -> Type
    Function : Type * list(Type) -> Type
    
    Union : list(Type) -> Type
    Intersection : list(Type) -> Type
  
  sorts TypeExpr
  constructors
    NamedType : ID -> TypeExpr
    UnionType : list(TypeExpr) -> TypeExpr
    IntersectionType : list(TypeExpr) -> TypeExpr
    ObjectType : list((ID * TypeExpr)) -> TypeExpr
    
namespaces  
  Var  : string
  Type : string

name-resolution
  labels P
  resolve Var filter pathMatch[P*] min pathLt[$ < P]

relations
  type : occurrence -> Type

rules
  main: Program
  
  main(program) :- {scope xyz number_scope string_scope boolean_scope}
	// Create base scope
	new scope,
	
	// Create property scopes for base types
	new number_scope,
	new string_scope,
	new boolean_scope,
	
	// Add types to scope
	scope -> Type{"number"@-} with type Number(number_scope),
	scope -> Type{"string"@-} with type String(string_scope),
	scope -> Type{"boolean"@-} with type Boolean(boolean_scope),
		
	// Test using queries if number is declared
	query decl
	  filter pathMatch[e] and { Type{"number"@-} }
	  min false and true
	in scope |-> [(_, _)],
	
	// Test if "string" is declared using a variable
	xyz == "string",
	Type{xyz@-} in scope |-> [(_, _)],
	
	// Test if "number" is associated with the number scope
	type of Type{"number"@-} in scope |-> [(_, (_, Number(number_scope)))],
		
    // Evaluate program
	eval_program(scope, program).

eval_program: scope * Program
  
  eval_program(scope, Program(statements)) :- 
    eval_statements(scope, statements, Void()).
  
eval_statements: scope * list(Statement) * Type

  eval_statements(scope, [], scope_type) :- true.
  eval_statements(scope, [statement | rest], scope_type) :- {local_scope}
    new local_scope, local_scope -P-> scope,
    eval_statement(local_scope, statement, scope_type),
    eval_statements(local_scope, rest, scope_type).
    
eval_statement: scope * Statement * Type
  
  eval_statement(scope, VarDecl(name, type', value), scope_type) :- {decl_type expr_type}
    decl_type == eval_type(scope, type'),
    expr_type == eval_expression(scope, value, decl_type),
    is_assignable(expr_type, decl_type),
    scope -> Var{name@-} with type decl_type.
  
  eval_statement(scope, TypeDecl(name, type'), scope_type) :- {decl_type}
    decl_type == eval_type(scope, type'),
    scope -> Type{name@-} with type decl_type.

  eval_statement(scope, FuncDecl(name, parameters, rtype_expr, body), scope_type) :- {return_type parameter_types function_scope}
    new function_scope, function_scope -P-> scope,
    return_type == eval_type(scope, rtype_expr),
    parameter_types == parse_parameters(scope, parameters, function_scope),
    eval_statements(function_scope, body, return_type),
    scope -> Var{name@-} with type Function(return_type, parameter_types).    

  eval_statement(scope, Assignment(name, value), scope_type) :- {decl_type expr_type}
    type of Var{name@-} in scope |-> [(_, (_, decl_type))],
    expr_type == eval_expression(scope, value, decl_type),
    is_assignable(expr_type, decl_type).

  eval_statement(scope, Return(value), scope_type) :- {expr_type}
    expr_type == eval_expression(scope, value, scope_type),
    is_assignable(expr_type, scope_type).

  eval_statement(scope, Interface(name, body), scope_type) :-
    scope -> Type{name@-} with type eval_type(scope, ObjectType(body)).

eval_expression: scope * Expression * Type -> Type

  eval_expression(scope, Identifier(properties), _) = T :-
    T == parse_dot_call(scope, properties).

  eval_expression(scope, FunctionCall(name, arguments), _) = return_type :- {function parameter_types}
    type of Var{name@-} in scope |-> [(_, (_, function))],
    function == Function(return_type, parameter_types),
    check_arguments(scope, arguments, parameter_types).

  eval_expression(scope, NumberLiteral(value), _) = T :-
    type of Type{"number"@-} in scope |-> [(_, (_, T))].
    
  eval_expression(scope, StringLiteral(value), _) = T :-
    type of Type{"string"@-} in scope |-> [(_, (_, T))].
  
  eval_expression(scope, BooleanLiteral(), _) = T :-
    type of Type{"boolean"@-} in scope |-> [(_, (_, T))].

  eval_expression(scope, ObjectLiteral(properties), expected_type) = Object(pscope) :-
    new pscope, 
    parse_object_literal(scope, properties, pscope, expected_type).

eval_type: scope * TypeExpr -> Type
eval_types maps eval_type(*, list(*)) = list(*)

  eval_type(scope, NamedType(name)) = T :-
    type of Type{name@-} in scope |-> [(_, (_, T))].
  
  eval_type(scope, UnionType(type_exprs)) = Union(types) :-
    types == eval_types(scope, type_exprs).
  
  eval_type(scope, IntersectionType(type_exprs)) = Intersection(types) :-
    types == eval_types(scope, type_exprs).
    
  eval_type(scope, ObjectType(properties)) = Object(pscope) :-
    new pscope, parse_object_type(scope, properties, pscope).

parse_object_literal: scope * list((ID * Expression)) * scope * Type

  parse_object_literal(scope, [], pscope, expected_type).
  
  parse_object_literal(scope, [(name, value) | rest], pscope, expected_type) :- {expected_property_type expr_type}
    // Checks whether an object literal does not contain a property which is not present in the expected type
	// Thus this prevents users from declaring properties in an object literal that are not present in the expected type
	// (even though this is allowed by sub typing rules)
    type of Var{name@-} in allowed_properties(expected_type) |-> [(_, (_, expected_property_type))],
    expr_type == eval_expression(scope, value, expected_property_type),
    is_assignable(expr_type, expected_property_type),
	// Declares the property in the object scope
    pscope -> Var{name@-} with type expr_type,
	// Parse rest of object literal
    parse_object_literal(scope, rest, pscope, expected_type).

parse_object_type: scope *  list((ID * TypeExpr)) * scope

  parse_object_type(scope, [], pscope).
  parse_object_type(scope, [(name, type_expr) | rest], pscope) :-
    pscope -> Var{name@-} with type eval_type(scope, type_expr),
    parse_object_type(scope, rest, pscope).

parse_parameter: scope * (ID * TypeExpr) * scope -> Type
parse_parameters maps parse_parameter(*, list(*), *) = list(*)

  parse_parameter(scope, (name, type'), function_scope) = parameter_type :-
    parameter_type == eval_type(scope, type'),
    function_scope -> Var{name@-} with type parameter_type.

parse_dot_call: scope * list(ID) -> Type

  parse_dot_call(scope, [name]) = T :-
    type of Var{name@-} in scope |-> [(_, (_, T))].

  parse_dot_call(scope, [name | properties]) = T | properties != [] 
    :- {variable_type variable_pscope}
    type of Var{name@-} in scope |-> [(_, (_, variable_type))],
    variable_pscope == properties_of(variable_type),
    T == parse_dot_call(variable_pscope, properties).    

check_argument: scope * Expression * Type
check_arguments maps check_argument(*, list(*), list(*))

  check_argument(scope, expression, parameter_type) :- {expr_type}
    expr_type == eval_expression(scope, expression, parameter_type),
    is_assignable(expr_type, parameter_type).

allowed_properties: Type -> scope

  allowed_properties(type') = properties_of(type') | type' != Union(_).
  allowed_properties(Union(types)) = compute_union_scope(types).

compute_union_scope: list(Type) -> scope

  compute_union_scope([A]) = properties_of(A).
  
  compute_union_scope([A, B]) = union_scope :-
    new union_scope,
    compute_unique_properties(union_scope, A, B),
    copy_properties(union_scope, union(A, B, find_unequal(A, B))).
  
  compute_union_scope([A, B | rest]) = union_scope | rest != [] :-
   union_scope == compute_union_scope([Object(compute_union_scope([A, B])) | rest]).

get_properties: scope -> list((path * occurrence))

  get_properties(scope) = query_result :-
    query decl
      filter pathMatch[e] and { Var{_@-} }
    in scope |-> query_result.

// Checks whether two types are identical
// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#3112-type-and-member-identity
is_identical: Type * Type
  
  is_identical(Number(_), Number(_)).
  is_identical(String(_), String(_)).
  is_identical(Boolean(_), Boolean(_)).
  
  is_identical(Union(a), Union(b)) :- 
    maps_to(a, b), maps_to(b, a).
    
  is_identical(Intersection(a), Intersection(b)) :- 
    maps_to(a, b), maps_to(b, a).
  
  is_identical(A@Object(a), B@Object(b)) :- 
    is_assignable(A, B), is_assignable(B, A).

// maps_to checks whether a set A is contained in a set B
maps: Type * list(Type)
maps_to maps maps(list(*), *)
contains maps maybe_identical(*, list(*)) = list(*)

  maps(A, types) :- {result}
    result == contains(A, types),
    assert_any(result).

maybe_identical: Type * Type -> list((path * occurrence))

  maybe_identical(A, B) = query_result :- {scope}
    // Create new scope and insert dummy declaration
    new scope,
    scope -> Var{"dummy"@-},
    
    // Perform query which will return an NON empty list if condition holds
    query decl
      filter pathMatch[e] and { d :- is_identical(A, B) }
    in scope |-> query_result.

// Check if A is assignable to B (A CAN BE ASSIGNED TO B)
// This is similar to subtyping
// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#3.11.4
is_assignable: Type * Type

// Checks whether a type can be assigned to atleast one type from a list of types
// or whether one type from a list of types is assignable to a type
union_assignable_any     maps maybe_assignable(*, list(*)) = list(*)
intersect_assignable_any maps maybe_assignable(list(*), *) = list(*)

// Checks whether a type can be assigned to all types in a list of types 
// or whether all types in a list of types can be assigned to a type
union_assignable_all     maps is_assignable(list(*), *)
intersect_assignable_all maps is_assignable(*, list(*))

  is_assignable(Number(_), Number(_)).
  is_assignable(String(_), String(_)).
  is_assignable(Boolean(_), Boolean(_)).
  
  is_assignable(A@Union(_), B@Union(_)) :- is_identical(A, B).
  is_assignable(A, Union(types)) | A != Union(_) :- {result}
    result == union_assignable_any(A, types),
    assert_any(result).
  is_assignable(Union(types), B) | B != Union(_) :- 
    union_assignable_all(types, B).
  
  is_assignable(A@Intersection(_), B@Intersection(_)) :- is_identical(A, B).  
  is_assignable(A, Intersection(types)) | A != Intersection(_) :- 
    intersect_assignable_all(A, types).
  is_assignable(Intersection(types), B) | B != Intersection(_) :- {result}
    result == intersect_assignable_any(types, B),
    assert_any(result).
  
  is_assignable(A, Object(pscope_b)) :- {pscope_a query_results}
    pscope_a == properties_of(A),
    query decl
      filter pathMatch[e] and { Var{_@-} }
    in pscope_b |-> query_results,
    recurse_properties(pscope_a, pscope_b, query_results).

// Checks whether the properties from a type A can be assigned to the properties of B
// Pretty much the same reasoning can be applied as if we were checking sub type relations
recurse_property: scope * scope * (path * occurrence)
recurse_properties maps recurse_property(*, *, list(*))

  recurse_property(pscope_a, pscope_b, (path, property)) :- {type_a type_b}
    // Type of property in A
    type of property in pscope_a |-> [(_, (_, type_a))],
    // Type of property in B
    type of property in pscope_b |-> [(_, (_, type_b))],    
    is_assignable(type_a, type_b).

// Checks whether type A can be assigned to type B and will return 
// a NON empty list when this is the case
maybe_assignable: Type * Type -> list((path * occurrence))

  maybe_assignable(A, B) = query_result :- {scope}
    // Create new scope and insert dummy declaration
    new scope,
    scope -> Var{"dummy"@-},
    
    // Perform query which will return an NON empty list if condition holds
    query decl
      filter pathMatch[e] and { d :- is_assignable(A, B) }
    in scope |-> query_result.

// Asserts that there is atleast one NON empty list in the list of lists
assert_any: list(list((path * occurrence)))

  assert_any([]) :- false.
  assert_any([[_] | rest]) :- true.
  assert_any([[ ] | rest]) :- assert_any(rest).

// Computes the properties of a given type
properties_of: Type -> scope

  properties_of(Object(pscope)) = pscope.
  
  properties_of(Number(number_scope)) = number_scope.
  properties_of(String(string_scope)) = string_scope.
  properties_of(Boolean(boolean_scope)) = boolean_scope.
  
  properties_of(Union(types@[first | rest])) = union_scope :- {pscope properties filtered_properties}
    new union_scope,
    pscope == properties_of(first),
    properties == get_properties(pscope),
    filtered_properties == filter_properties(properties, types),
    unionise(filtered_properties, union_scope).
  
  properties_of(Intersection(types)) = compute_intersect_scope(types).

compute_intersect_scope: list(Type) -> scope

  compute_intersect_scope([A]) = properties_of(A).
  
  compute_intersect_scope([A, B]) = intersect_scope :-
    new intersect_scope,
    compute_unique_properties(intersect_scope, A, B),
    copy_properties(intersect_scope, intersect(A, B, find_unequal(A, B))).
  
  compute_intersect_scope([A, B | rest]) = intersect_scope | rest != [] :- {T}
    T == compute_intersect_scope([A, B]),
    intersect_scope == compute_intersect_scope([Object(T) | rest]).

// Computes the properties present in either A or in B or in A and B and of the same type
compute_unique_properties: scope * Type * Type

  compute_unique_properties(new_type, A, B) :- {a b props_a props_b}
    // Compute scope assocciated with types
    a == properties_of(A),
    b == properties_of(B),
    
    // Copy the properties that are present in both a and b of the same type
    copy_equal(new_type, a, b),
    
    // Copy the properties present in a but not in b
    query decl
      filter pathMatch[e] and { d :- type of d in b |-> [ ] }
    in a |-> props_a,
    copy_properties(new_type, to_types(props_a)),
    
    // Copy the properties present in b but not in a
    query decl
      filter pathMatch[e] and { d :- type of d in a |-> [ ] }
    in b |-> props_b,
    copy_properties(new_type, to_types(props_b)).

// Given two types and a property present in both types computes the intersection of 
// the type of the property in both types
intersect_: Type * Type * (path * occurrence) -> (occurrence * Type)
intersect maps intersect_(*, *, list(*)) = list(*)

  intersect_(A, B, (path, property)) = (property, Intersection([type_a, type_b])) :-
    type of property in properties_of(A) |-> [(_, (_, type_a))],
    type of property in properties_of(B) |-> [(_, (_, type_b))].

union_: Type * Type * (path * occurrence) -> (occurrence * Type)
union maps union_(*, *, list(*)) = list(*)

  union_(A, B, (path, property)) = (property, Union([type_a, type_b])) :-
    type of property in properties_of(A) |-> [(_, (_, type_a))],
    type of property in properties_of(B) |-> [(_, (_, type_b))].

// Transforms (path * occurrence) to (occurrence * Type)
to_type: (path * occurrence) -> (occurrence * Type)
to_types maps to_type(list(*)) = list(*)

  to_type((path, property)) = (property, type') :-
    type of property in dst(path) |-> [(_, (_, type'))].

// Finds the properties that are present in both types
// but that are of different type in each type
find_unequal: Type * Type -> list((path * occurrence))

  find_unequal(A, B) = properties :- {a b}
    a == properties_of(A),
    b == properties_of(B),
    query decl
      filter pathMatch[e] and {
        d :- {ta tb}
          d == Var{_@-},
          
          type of d in a |-> [(_, (_, ta))],
          type of d in b |-> [(_, (_, tb))],
          
          // Kinda hacky but allows us to check whether two types are NOT equal
          // When two types are equal the filter condition will be true
          // and the output of the query will be a non empty list
          // However when two types are not equal the result of the query
          // will be an empty list which we can use to filter in the outer filter
          query decl
            filter pathMatch[e] and { d :- is_identical(ta, tb) }
          in b |-> [ ]
      }
    in a |-> properties.
 
// Copy a list of properties to a type
copy_property: scope * (occurrence * Type)
copy_properties maps copy_property(*, list(*))
  
  copy_property(new_type, (property, prop_type)) :-
    new_type -> property with type prop_type.

// Copy the properties that are present in both types and type equal
copy_equal: scope * scope * scope

  copy_equal(new_type, a, b) :- { properties }
    query decl
      filter pathMatch[e] and {
        d :- {ta tb}
          d == Var{_@-},
        
          type of d in a |-> [(_, (_, ta))],
          type of d in b |-> [(_, (_, tb))],
          
          is_identical(ta, tb)
      }
    in a |-> properties,
    copy_properties(new_type, to_types(properties)).

filter_property: (path * occurrence) * list(Type) -> (occurrence * list(Type))
filter_properties maps filter_property(list(*), *) = list(*)

  filter_property((path, property), types) = (property, declared_types) :- {extracted_types transformed_types}
    extracted_types == extract_types(property, types),
    transformed_types == transform_types(extracted_types),
    declared_types == remove_empty(transformed_types).

extract_type: occurrence * Type -> list((path * (occurrence * Type)))
extract_types maps extract_type(*, list(*)) = list(*)

  extract_type(property, type') = result :- {pscope}
    pscope == properties_of(type'),
    type of property in pscope |-> result.

transform_type: list((path * (occurrence * Type))) -> list(Type)
transform_types maps transform_type(list(*)) = list(*)

  transform_type([]) = [].
  transform_type([(_, (_, T))]) = [T].

remove_empty: list(list(Type)) -> list(Type)

  remove_empty([ ]) = [].
  remove_empty([[ ] | rest]) = remove_empty(rest).
  remove_empty([[T] | rest]) = [T | remove_empty(rest)].

insert_union: (occurrence * list(Type)) * scope
unionise maps insert_union(list(*), *)

  insert_union((property, []), union_scope).
  insert_union((property, types), union_scope) :-
    union_scope -> property with type Union(types).