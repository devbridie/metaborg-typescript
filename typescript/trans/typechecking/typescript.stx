module typescript

signature
  sorts ID = string

  sorts VariableType Let Const Var
  constructors
    Const: Const -> VariableType
    Let  : Let   -> VariableType
    Var  : Var   -> VariableType
  
  sorts Program
  constructors
    Program: list(Statement) -> Program

  sorts Statement
  constructors
    Declaration : ID * ID * Expression -> Statement
    Assignment  : ID * Expression -> Statement
    Interface   : ID * list((ID * ID)) -> Statement

  sorts Expression
  constructors
    Identifier    : ID -> Expression
    NumberLiteral : ID -> Expression
    StringLiteral : ID -> Expression
    ObjectLiteral : list((ID * Expression)) -> Expression

  sorts Type
  constructors
    Number : Type
    String : Type
    Object : scope -> Type

namespaces  
  Var  : string
  Type : string

relations
  type : occurrence -> Type

rules
  main: Program
  
  main(program) :- {scope}
    new scope,
//    scope -> Type{"number"@program} with type Number(),
//    scope -> Type{"string"@program} with type String(),
    eval_program(scope, program).

rules  
  eval_program: scope * Program
  
  eval_program(scope, Program([ ])) :- true.
  
  eval_program(scope, Program([statement | rest])) :- 
    eval_statement(scope, statement),
    eval_program(scope, Program(rest)).

rules    
  eval_statement: scope * Statement
  
  eval_statement( scope, Declaration(name, type', value) ) :- {ExprType DeclType}
    eval_expression(scope, value) == ExprType,
    
//    type of Type{"number"@type'} in scope |-> [(_, (_, DeclType))],
    eval_type(scope, type') == DeclType,
    
    scope -> Var{name@name} with type ExprType,
    is_subtype(ExprType, DeclType).
  
  eval_statement( scope, Assignment(name, value) ) :- {ExprType DeclType}
    eval_expression(scope, value) == ExprType,
    type of Var{name@name} in scope |-> [(_, (_, DeclType))],
    ExprType == DeclType.
  
  eval_statement( scope, Interface(name, properties) ) :- {pscope}
    new pscope,
    interface_type(scope, properties, pscope),
    scope -> Type{name@name} with type Object(pscope).

rules
  eval_expression: scope * Expression -> Type
  
  eval_expression( scope, NumberLiteral(value) ) = Number().
  eval_expression( scope, StringLiteral(value) ) = String().
    
  eval_expression( scope, Identifier(name) ) = Number() :- {ps}
    query decl 
       filter pathMatch[e] and { d :- {p} d == Var{name@p} }
       min false and true 
    in scope |-> [(_, _)].
  
  eval_expression( scope, ObjectLiteral(properties) ) = Object(pscope) :-
    new pscope,
    object_type(scope, properties, pscope).

rules
  eval_type: scope * ID -> Type
  
  eval_type(scope, "number") = Number().
  eval_type(scope, "string") = String().
  eval_type(scope, name) = Number()  :-
    query decl 
       filter pathMatch[e] and { d :- {p} d == Type{name@p} }
       min false and true 
    in scope |-> [(_, _)].

rules
  interface_type: scope * list((ID * ID)) * scope
  
  interface_type(scope, [ ], pscope).
  interface_type(scope, [(name, type') | rest], pscope):- {PropType}
    eval_type(scope, type') == PropType,
//    type of Type{type'@type'} in scope |-> [(_, (_, PropType))],
    
    pscope -> Var{name@name} with type PropType,
    interface_type(scope, rest, pscope).

rules
  object_type: scope * list((ID * Expression)) * scope 
  
  object_type(scope, [ ], pscope).
  object_type(scope, [(name, value) | rest], pscope) :- {ExprType}
    eval_expression(scope, value) == ExprType,
    pscope -> Var{name@name} with type ExprType,
    object_type(scope, rest, pscope).
    
constraint
  is_subtype: Type * Type
  
  is_subtype(Number(), Number()).
  is_subtype(String(), String()).
  is_subtype(Object(_), Object(_)).