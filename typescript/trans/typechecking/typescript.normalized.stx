module typescript2

signature

  sorts
    ID = string

  sorts
    VariableType
    Let
    Const
    Var

  constructors
    Const : Const -> VariableType
    Let : Let -> VariableType
    Var : Var -> VariableType

  sorts
    Program

  constructors
    Program : list(Statement) -> Program

  sorts
    Statement

  constructors
    Declaration : ID * ID * Expression -> Statement
    Assignment : ID * Expression -> Statement
    Interface : ID * list((ID * ID)) -> Statement

  sorts
    Expression

  constructors
    Identifier : ID -> Expression
    NumberLiteral : ID -> Expression
    StringLiteral : ID -> Expression
    ObjectLiteral : list((ID * Expression)) -> Expression

  sorts
    Type

  constructors
    Number : Type
    String : Type
    Object : scope -> Type

  namespaces
    Var : string
    Type : string

  relations
    type : occurrence -> Type

rules

  constraint main : Program

  main(program) | {} true :- {scope}
    new scope,
    (!decl[Type{ "number" @program }] in scope,
    !type[Type{ "number" @program }, Number(  )] in scope),
    (!decl[Type{ "string" @program }] in scope,
    !type[Type{ "string" @program }, String(  )] in scope),
    eval_program(scope, program).

rules

  constraint eval_program : scope * Program

  eval_program(scope, p86) | {} p86 == Program( [] ),
  true :- {}
    true.

  eval_program(scope, p88) | {statement rest} p88 == Program( [statement|rest] ),
  true :- {}
    eval_statement(scope, statement),
    eval_program(scope, Program( rest )).

rules

  constraint eval_statement : scope * Statement

  eval_statement(scope, p89) | {name type' value} p89 == Declaration( name, type', value ),
  true :- {ExprType DeclType eval_expression39 wld233 wld234}
    eval_expression(scope, value, eval_expression39),
    eval_expression39 == ExprType,
    query type filter { lbls :- {} resolveFilterWf15(Type{ "number" @type' }, lbls) } and { d :- {} resolveFilterEq15(Type{ "number" @type' }, d) } min { l1, l2 :- {} resolveMinOrd15(Type{ "number" @type' }, l1, l2) } and { d1, d2 :- {} true } in scope |-> [(wld233, (wld234, DeclType))],
    (!decl[Var{ name @name }] in scope,
    !type[Var{ name @name }, DeclType] in scope),
    is_subtype(ExprType, DeclType).

  eval_statement(scope, p90) | {name value} p90 == Assignment( name, value ),
  true :- {ExprType DeclType eval_expression40 wld235 wld236}
    eval_expression(scope, value, eval_expression40),
    eval_expression40 == ExprType,
    query type filter { lbls :- {} resolveFilterWf15(Var{ name @name }, lbls) } and { d :- {} resolveFilterEq15(Var{ name @name }, d) } min { l1, l2 :- {} resolveMinOrd15(Var{ name @name }, l1, l2) } and { d1, d2 :- {} true } in scope |-> [(wld235, (wld236, DeclType))],
    ExprType == DeclType.

  eval_statement(scope, p91) | {name properties} p91 == Interface( name, properties ),
  true :- {pscope}
    new pscope,
    interface_type(scope, properties, pscope),
    !decl[Type{ name @name }] in scope,
    !type[Type{ name @name }, Object( pscope )] in scope.

rules

  constraint eval_expression : scope * Expression * Type

  eval_expression(scope, p92, p93) | {value} p92 == NumberLiteral( value ),
  true :- {}
    p93 == Number(  ),
    true.

  eval_expression(scope, p94, p95) | {value} p94 == StringLiteral( value ),
  true :- {}
    p95 == String(  ),
    true.

  eval_expression(scope, p96, T) | {name} p96 == Identifier( name ),
  true :- {wld237 wld238}
    query type filter { lbls :- {} resolveFilterWf15(Var{ name @name }, lbls) } and { d :- {} resolveFilterEq15(Var{ name @name }, d) } min { l1, l2 :- {} resolveMinOrd15(Var{ name @name }, l1, l2) } and { d1, d2 :- {} true } in scope |-> [(wld237, (wld238, T))].

  eval_expression(scope, p97, p98) | {properties} p97 == ObjectLiteral( properties ),
  true :- {pscope}
    p98 == Object( pscope ),
    new pscope,
    object_type(scope, properties, pscope).

rules

  constraint eval_type : scope * ID * Type

  eval_type(scope, p99, p100) | {} p99 == "number",
  true :- {}
    p100 == Number(  ),
    true.

  eval_type(scope, p101, p102) | {} p101 == "string",
  true :- {}
    p102 == String(  ),
    true.

  eval_type(scope, name, T) | {} true :- {wld239 wld240}
    query type filter { lbls :- {} resolveFilterWf15(Type{ name @name }, lbls) } and { d :- {} resolveFilterEq15(Type{ name @name }, d) } min { l1, l2 :- {} resolveMinOrd15(Type{ name @name }, l1, l2) } and { d1, d2 :- {} true } in scope |-> [(wld239, (wld240, T))].

rules

  constraint interface_type : scope * list((ID * ID)) * scope

  interface_type(scope, p103, pscope) | {} p103 == [],
  true :- {}
    true.

  interface_type(scope, p104, pscope) | {name type' rest} p104 == [(name, type')|rest],
  true :- {PropType wld241 wld242}
    query type filter { lbls :- {} resolveFilterWf15(Type{ type' @type' }, lbls) } and { d :- {} resolveFilterEq15(Type{ type' @type' }, d) } min { l1, l2 :- {} resolveMinOrd15(Type{ type' @type' }, l1, l2) } and { d1, d2 :- {} true } in scope |-> [(wld241, (wld242, PropType))],
    (!decl[Var{ name @name }] in pscope,
    !type[Var{ name @name }, PropType] in pscope),
    interface_type(scope, rest, pscope).

rules

  constraint object_type : scope * list((ID * Expression)) * scope

  object_type(scope, p105, pscope) | {} p105 == [],
  true :- {}
    true.

  object_type(scope, p106, pscope) | {name value rest} p106 == [(name, value)|rest],
  true :- {ExprType eval_expression41}
    eval_expression(scope, value, eval_expression41),
    eval_expression41 == ExprType,
    (!decl[Var{ name @name }] in pscope,
    !type[Var{ name @name }, ExprType] in pscope),
    object_type(scope, rest, pscope).

  constraint is_subtype : Type * Type

  is_subtype(p107, p108) | {} p107 == Number(  ),
  p108 == Number(  ),
  true :- {}
    true.

  is_subtype(p109, p113) | {} p109 == String(  ),
  p113 == String(  ),
  true :- {}
    true.

  is_subtype(p114, p115) | {wld243 wld244} p114 == Object( wld243 ),
  p115 == Object( wld244 ),
  true :- {}
    true.

rules


rules

  constraint resolveFilterWf15 : occurrence * list(label)

  resolveFilterWf15(r, lbls) | {wld1 wld2} r == Var{ wld2 @wld1 } :- {}
    true.

  resolveFilterWf15(r, lbls) | {wld1 wld2} r == Type{ wld2 @wld1 } :- {}
    true.

  constraint resolveFilterEq15 : occurrence * occurrence

  resolveFilterEq15(r, d) | {wld1 t} r == Var{ t @wld1 } :- {wld2 u}
    d == Var{ u @wld2 },
    t == u.

  resolveFilterEq15(r, d) | {wld1 t} r == Type{ t @wld1 } :- {wld2 u}
    d == Type{ u @wld2 },
    t == u.

  constraint resolveMinOrd15 : occurrence * label * label

  resolveMinOrd15(r, l1, l2) | {wld1 wld2} r == Var{ wld2 @wld1 } :- {}
    false.

  resolveMinOrd15(r, l1, l2) | {wld1 wld2} r == Type{ wld2 @wld1 } :- {}
    false.
    