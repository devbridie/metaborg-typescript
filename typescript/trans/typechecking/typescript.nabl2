module typechecking/typescript

imports

  signatures/-
  typechecking/-
  
signature
    
    
    constructors
    	RECORD	: scope -> Type
    	
    	NUMBER	  : Type
		  STRING	  : Type
		  BOOLEAN   : Type
		  UNDEFINED : Type
		  FUNCTION  : list(Type) * Type -> Type
		

	name resolution
		labels
	      P I
	
	    order
	      D < I,
	      D < P,
	      I < P
	
	    well-formedness
	      P* . I*
      
		namespaces
			Field
			Type
			Value
			Return
      
rules
	
	init ^ (s) :=
    	new s.
    
    [[ Program(statements) ^ (s) ]] :=
    	Map1 [[ statements ^ (s) ]],
    	distinct/name D(s)/Value | error @ NAMES,
    	distinct/name D(s)/Type | error @ NAMES.
    	
    	
    [[ InterfaceDecl(name, _, fields) ^ (s) ]] :=
    	Type{name} <- s,
    	Type{name} : ty !,
    	[[ fields ^ (s): ty ]].
    
    [[ ObjectType(fields) ^ (s): ty ]] :=
    	new record_scope,
    	ty == RECORD(record_scope),
    	record_scope -P-> s,
    	distinct/name D(record_scope)/Field | error $[Duplicate declaration of field] @ NAMES,
    	Map1 [[ fields ^ (record_scope) ]].
    
    [[ TypeMember(name, _, None()) ^ (s) ]] := false.
    
   	[[ TypeMember(name, _, Some(type)) ^ (s) ]] :=
   		Field{name} <- s,
   		Field{name} : ty !,
   		[[ type ^ (s): ty]].
   	
   	[[ TypeAnnotation(Number()) ^(_): NUMBER()]] := true.
   	[[ TypeAnnotation(String()) ^(_): STRING()]] := true.
   	
   	[[ TypeAnnotation(Object(objectType)) ^ (s): ty ]] :=
   	  [[ objectType ^ (s) : ty ]].
    	
    [[ TypeAnnotation(Id(name)) ^ (s): ty ]] :=
    	Type{name} -> s,
    	Type{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    	
    [[ Lexical(_, declarations, _) ^ (s) ]] :=
    	Map1 [[ declarations ^ (s) ]].
    
    [[ Variable(declarations, _) ^ (s) ]] :=
      Map1 [[ declarations ^ (s) ]].
    
    [[ SimpleVariableDeclaration(name, None(), Some(value)) ^ (s) ]] := 
      [[ value ^ (s) : valueTy ]],
      Value{name} <- s,
      Value{name} : valueTy.

    [[ SimpleVariableDeclaration(name, Some(type), None()) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]].

    [[ SimpleVariableDeclaration(name, Some(type), Some(value)) ^ (s) ]] :=
    	Value{name} <- s,
    	Value{name} : ty !,
    	[[ type ^ (s) : ty ]],
    	[[ value ^ (s) : valueTy ]],
    	ty <? valueTy.
    
    [[ Number(_) ^ (_): NUMBER() ]] := true.
    [[ String(_) ^ (_): STRING() ]] := true.
    [[ True() ^ (_): BOOLEAN() ]] := true.
    [[ False() ^ (_): BOOLEAN() ]] := true.
    
    [[ Expression(expression, _) ^ (s) ]] :=
      [[ expression ^ (s): ty ]].
    
    [[ Id(name) ^ (s) : ty ]] :=
      Value{name} -> s,
      Value{name} |-> d | error $[Cannot resolve [name]],
        d : ty.
    
    [[ Function(name, CallSignature(_, parameters, returnType), body) ^ (s) ]] :=
      new function_scope,
      [[ name ^ (s): FUNCTION(paramsTy, returnTy) ]],
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : returnTy ]],
      Return{"function"} <- function_scope,
      Return{"function"} : returnTy,
      Map1 [[ body ^ (function_scope) ]].
    
    [[ FunctionName(name) ^ (s) : ty ]] :=
      Value{name} <- s,
      Value{name} : ty !.
    [[ NoName() ^ (_) : ty ]].
    
    [[ NoParameters() ^ (_) : [] ]].
    [[ Parameters(parameters) ^ (s, function_scope) : paramsTy ]] :=
      [[ parameters ^ (s, function_scope): paramsTy ]].
    
    [[ NoReturnType() ^ (_) : ty ]].
    [[ ReturnType(type) ^ (s) : returnTy ]] :=
      [[ type ^ (s): returnTy ]].
    
    [[ FunctionExpression(Function(_, CallSignature(_, parameters, returnType), body)) ^ (s): FUNCTION(paramsTy, returnTy) ]] :=
      new function_scope,
      [[ parameters ^ (s, function_scope): paramsTy ]],
      [[ returnType ^ (s) : returnTy ]],
      Return{"function"} <- function_scope,
      Return{"function"} : returnTy,
      Map1 [[ body ^ (function_scope) ]].
     
    [[ RequiredParameterList(parameters) ^ (s, function_scope) : ty ]] :=
      Map2T [[ parameters ^ (s, function_scope): ty ]].
    
    [[ RequiredParameter(name, None()) ^ (s, function_scope) : ty ]] := false.
     
    [[ RequiredParameter(name, Some(type)) ^ (s, function_scope) : ty ]] :=
      Value{name} <- function_scope,
      Value{name} : ty !,
      [[ type ^ (s) : ty ]].
    
    [[ If(condition, trueBlock) ^ (s) ]] :=
      [[ condition ^ (s) : valueTy ]],
      valueTy == BOOLEAN() | error $[Boolean expected, got [valueTy]],
      [[ trueBlock ^ (s) ]].
    
    [[ IfElse(condition, trueBlock, falseBlock) ^ (s) ]] :=
      [[ condition ^ (s) : valueTy ]],
      valueTy == BOOLEAN() | error $[Boolean expected, got [valueTy]],
      [[ trueBlock ^ (s) ]],
      [[ falseBlock ^ (s) ]].
    
    [[ Block(statements) ^ (s) ]] :=
      Map1 [[ statements ^ (s) ]].
    
    [[ ValueReturn(value, _) ^ (s) ]] :=
      [[ value ^ (s) : valueTy ]],
      Return{"function"} -> s,
      Return{"function"} |-> d | error $[Can not use return outside of a function scope],
      d: ty,
      ty == valueTy.
    
    [[ EmptyReturn() ^ (s) ]] :=
      Return{"function"} -> s,
      Return{"function"} |-> d | error $[Can not use return outside of a function scope],
      d: ty,
      ty == UNDEFINED().
    
    [[ Call(function, arguments) ^ (s) : ty ]] :=
      [[ function ^ (s) : functionTy ]],
      functionTy == FUNCTION(paramsTy, ty),
      Map1T [[ arguments ^ (s): argsTy ]],
      argsTy <? paramsTy.
    	
    [[ ObjectDecl(properties) ^ (s): ty ]] :=
      new record_scope,
      ty == RECORD(record_scope),
      Map2 [[ properties ^ (s, record_scope) ]],
      distinct/name D(record_scope)/Field | error $[Duplicate declaration of field] @ NAMES.
    
    [[ Property(name, value) ^ (s, record_scope) ]] :=
      [[ value ^ (s) : valueTy ]],
      Field{name} <- record_scope,
      Field{name} : valueTy !.
    
    [[ PropertyLookup(record, field) ^ (s) : ty ]] :=
      [[ record ^ (s) : recordTy ]],
      recordTy == RECORD(record_scope) | error $[Record expected, got $[recordTy]],
      new s_use,
      s_use -I-> record_scope,
      Field{field} -> s_use,
      Field{field} |-> d | error $[Can not find field $[field] in record $[record]],
      d: ty.   
    	
    	