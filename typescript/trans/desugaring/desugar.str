module desugar

imports
	signatures/-
	pp
	libspoofax/stratego/debug
signature
	constructors
	InferredType: TypeExpr
	
	SingleVariableDeclaration                    : VariableDeclarationType * ID * TypeExpr * Expression -> VarDeclaration
	ImportMember : STRING * ID * ID -> Statement
	
rules
  desugar: Program(l) -> Program(<flatten-list> <map(wrap-if-single)> <map(topdown(try(bottomup(try(desugar)))))> l)
  desugar: StatementList(l) -> StatementList(<flatten-list> <map(wrap-if-single)> <map(topdown(try(bottomup(try(desugar)))))> l)
  wrap-if-single: a@[_|_] -> a
  wrap-if-single: a -> [a]
  desugar: VariableDeclarationNoInitializer(b) -> VariableDeclarationWithInitializer(b, UndefinedLiteral())
  desugar: NameWithNoType(n) -> NameWithType(n, InferredType())
  desugar: ArrowExprExpr(sig, expr) -> ArrowExprBlock(sig, [ValueReturn(expr)])
  desugar: ArrowExprBlock(sig, statements) -> AnonymousFunction(sig, statements)
  desugar: NoTypeAnnotation() -> TypeAnnotation(InferredType())
//  desugar: MemberExpr(par, n) -> ArrayAccessExpr(par, StringLiteral(n))
  desugar: ExpressionStatement(FunctionDeclaration(name, sig, body)) -> <desugar> VariableDeclaration(Const(), [VariableDeclarationWithInitializer(NameWithType(name, <sig2type> sig), AnonymousFunction(sig, body))])
  sig2type: CallSignature(params, NoTypeAnnotation()) -> result where 
    newparams := <map(\NameWithType(n, t) -> t \)> params;
    result := FunctionType(newparams, InferredType())
  sig2type: CallSignature(params, TypeAnnotation(ty)) -> result where 
    newparams := <map(\NameWithType(n, t) -> t \)> params;
    result := FunctionType(newparams, ty)
  desugar: PropertyMemberWithoutInitializer(n) -> PropertyMemberWithInitializer(n, UndefinedLiteral())
  desugar: ExpressionStatement(c@ClassExpr(n, ClassParent(p), i, e)) -> [
    InterfaceDeclaration(n, p, <map(member2type)> e),
     VariableDeclaration(Const(), [VariableDeclarationWithInitializer(NameWithType(n, 
      StructureType([NameWithType("new", FunctionType([], IdType(n)))])
    ), c)])
  ]
  desugar: FunctionMember(mods, n, sig, statements) -> 
  PropertyMemberWithInitializer(NameWithType(n, <sig2type> sig), AnonymousFunction(sig, statements)) 
  
  desugar: NamedImport(name) -> AsImport(name, name)
  
  desugar: ImportClause(ImportsList(items), From(name)) -> <map(\AsImport(n, n2) -> ImportMember(name, n, n2) \)> items
  
  desugar: VariableDeclaration(ty, decls) -> 
     <map(\VariableDeclarationWithInitializer(NameWithType(n, t), i) -> SingleVariableDeclaration(ty, n, t, i)\)> decls
     
  desugar: MemberFn(name, sig) -> Member(NameWithType(name, <sig2type> sig))
  desugar: Member(n) -> n
  desugar: NoImplements() -> Implements([])
  desugar: InterfaceDeclarationNoExtends(i,im) -> InterfaceDeclaration(i, "Object", im)
  desugar: NoParent() -> ClassParent("Object")
  removesemis: a -> result where <not(is-string)> a;
        constructor := <removesm> <get-constructor> a;
        args := <get-arguments> a; 
        result := <mkterm>(constructor, args)
  removesm: str -> <string-replace(|"__C", "")> <string-replace(|"__SM", "")> str where <is-string> str

  member2type: PropertyMemberWithInitializer(NameWithType(n, t), e) -> NameWithType(n, t)
strategies
  	desugar-all: ast -> result with
  	   removed := <topdown(try(removesemis))> ast;  	
  	   result := <desugar> removed
  	   